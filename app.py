import os
import json
import uuid
from datetime import datetime
from typing import List, Dict, Any

import streamlit as st
from dotenv import load_dotenv
from openai import OpenAI

# ---------- Setup ----------
load_dotenv()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
client = OpenAI(api_key=OPENAI_API_KEY)
MODEL = "gpt-4o-mini"

st.set_page_config(page_title="Clinical Intake Chatbot", page_icon="ðŸ’¬", layout="centered")

# ---------- CSS ----------
st.markdown("""
<style>
.block-container { padding-top: 1.2rem; }
.section-title { font-weight: 700; font-size: 1.06rem; margin: 12px 0 6px; }
.helper { color: #6b7280; font-size: 0.9rem; margin-bottom: 8px; }
.question-card { padding: 12px 14px; border: 1px solid #e6e6e6; border-radius: 8px; background: #fafafa; margin-bottom: 10px; }
div.stButton > button { border-radius: 8px; border: 1px solid #d9d9d9; }
hr.soft { border: 0; border-top: 1px solid #eee; margin: 12px 0; }
.badge { display:inline-block; background:#eef2ff; color:#3730a3; padding:2px 8px; border-radius:9999px; font-size: 0.8rem; }
.mode-pill { display:inline-block; background:#ecfeff; color:#0369a1; padding:4px 10px; border-radius:9999px; font-size: 0.85rem; margin-left: 8px; }
</style>
""", unsafe_allow_html=True)

st.title("Clinical Intake Chatbot")
st.caption("Step 1: Basic details â†’ Step 2: Chat-style questions â†’ Summary")
st.markdown('<span class="mode-pill">Details â†’ Q&A â†’ Summary</span>', unsafe_allow_html=True)

# ---------- Session State ----------
if "sid" not in st.session_state:
    st.session_state.sid = str(uuid.uuid4())

if "ctx" not in st.session_state:
    st.session_state.ctx = {
        "mode": "intake",  # intake | chat
        "appointment_type": None,
        "general_schema": None,          # generated by AI
        "general_answers": {},           # only what user typed/selected
        "general_skipped": set(),
        "problem_schema": None,          # generated by AI
        "problem_qs": [],                # list of questions
        "problem_answers": {},           # only what user typed/selected
        "problem_skipped": set(),
        "problem_idx": 0,                # index for one-by-one flow
        "summary": "",
        "completed": False,
        "chat_history": [],
        "ui_stage": "details",          # details | chat
        "meta": {
            "last_cc": "",
            "last_gender": "",
            "last_appt": "",
        }
    }

ctx = st.session_state.ctx

# ---------- Utilities ----------
def safe_get_questions(obj: Dict[str, Any]) -> List[Dict[str, Any]]:
    if not isinstance(obj, dict):
        return []
    qs = obj.get("questions", [])
    return qs if isinstance(qs, list) else []

def oai_json(system: str, user: str, schema: Dict[str, Any], temperature=0.2) -> Dict[str, Any]:
    try:
        resp = client.chat.completions.create(
            model=MODEL,
            temperature=temperature,
            messages=[{"role":"system","content":system},{"role":"user","content":user}],
            response_format={"type":"json_schema","json_schema":schema}
        )
        return json.loads(resp.choices[0].message.content)
    except Exception as e:
        st.error(f"OpenAI JSON error: {e}")
        return {}

def oai_text(system: str, user: str, temperature=0.2, max_tokens=800) -> str:
    try:
        resp = client.chat.completions.create(
            model=MODEL,
            temperature=temperature,
            max_tokens=max_tokens,
            messages=[{"role":"system","content":system},{"role":"user","content":user}],
        )
        return resp.choices[0].message.content or ""
    except Exception as e:
        st.error(f"OpenAI text error: {e}")
        return ""

def build_payload_for_summary(ctx: Dict[str, Any]) -> Dict[str, Any]:
    gen = {k:v for k,v in ctx["general_answers"].items() if k not in ctx["general_skipped"] and str(v).strip() != ""}
    prob = {k:v for k,v in ctx["problem_answers"].items() if k not in ctx["problem_skipped"] and str(v).strip() != ""}
    return {
        "session_id": st.session_state.sid,
        "timestamp": datetime.utcnow().isoformat(),
        "appointment_type": ctx["appointment_type"],
        "general_schema": ctx["general_schema"],
        "general_answers": gen,
        "general_skipped": sorted(list(ctx["general_skipped"])),
        "problem_schema": ctx["problem_schema"],
        "problem_questions": ctx["problem_qs"],
        "problem_answers": prob,
        "problem_skipped": sorted(list(ctx["problem_skipped"])),
    }

# ---------- AI Prompt Templates ----------
GENERAL_SCHEMA_PROMPT = """
You are a clinical intake form designer.
Task: Generate a gender-aware, appointment-aware GENERAL QUESTIONS schema to collect baseline information.

Input:
- Appointment type: {appointment_type}
- Gender: {gender}

Requirements:
- Output a concise list of 12â€“20 general questions that are broadly applicable and safe.
- Include gender-specific items appropriately (e.g., menstruation/LMP for female where relevant; pregnancy planning; hormonal therapy where applicable).
- Keep question labels short and unambiguous.
- Field types must be one of: ["text","textarea","number","select","date","time"].
- If type is "select", include an "options" array of strings.
- Include a "required" boolean for each field.
- Provide machine-friendly unique "id" in snake_case.
- Avoid personally identifying information beyond full name and city.
- Do NOT include problem-specific questions here.
- This is a schema only, do not include default answers.

Return JSON strictly as:
{{ "questions": [ {{ "id": "...", "label": "...", "type": "...", "required": true/false, "options": [...]? }} ] }}
"""

GENERAL_SCHEMA_JSON = {
    "type": "object",
    "properties": {
        "questions": {
            "type": "array",
            "minItems": 12,
            "maxItems": 20,
            "items": {
                "type": "object",
                "properties": {
                    "id": {"type":"string"},
                    "label": {"type":"string"},
                    "type": {"type":"string", "enum":["text","textarea","number","select","date","time"]},
                    "required": {"type":"boolean"},
                    "options": {
                        "type":"array",
                        "items":{"type":"string"},
                        "nullable": True
                    }
                },
                "required": ["id","label","type","required"],
                "additionalProperties": False
            }
        }
    },
    "required": ["questions"],
    "additionalProperties": False
}

PROBLEM_SCHEMA_PROMPT = """
You are a clinical intake assistant.
Task: Generate 5â€“10 PROBLEM-SPECIFIC questions based on the user's presenting concern.

Input:
- Appointment type: {appointment_type}
- Gender: {gender}
- Chief complaint: {chief_complaint}

Requirements:
- Focus on severity, onset/duration, pattern, triggers, associated symptoms, treatments tried, red flags, contraindications, impact on life.
- Keep labels short, unambiguous, 1 line if possible.
- Field types must be one of: ["text","textarea","number","select","date","time"].
- If "select", include an "options" array.
- Provide unique "id" (snake_case) and "required" boolean.
- This is a schema only, do not include default answers.

Return JSON strictly as:
{{ "questions": [ {{ "id": "...", "label": "...", "type": "...", "required": true/false, "options": [...]? }} ] }}
"""

PROBLEM_SCHEMA_JSON = {
    "type": "object",
    "properties": {
        "questions": {
            "type": "array",
            "minItems": 5,
            "maxItems": 10,
            "items": {
                "type": "object",
                "properties": {
                    "id": {"type":"string"},
                    "label": {"type":"string"},
                    "type": {"type":"string", "enum":["text","textarea","number","select","date","time"]},
                    "required": {"type":"boolean"},
                    "options": {
                        "type":"array",
                        "items":{"type":"string"},
                        "nullable": True
                    }
                },
                "required": ["id","label","type","required"],
                "additionalProperties": False
            }
        }
    },
    "required": ["questions"],
    "additionalProperties": False
}

"""
Fixed, clinician-provided questions only. The app will not generate questions with AI anymore.
"""
FIXED_GENERAL_SCHEMA = {
    "questions": [
        {"id": "presenting_concern", "label": "Presenting Concern/Complaints", "type": "text", "required": True},
        {"id": "expected_treatment_result", "label": "Expecting Result From the Treatment", "type": "text", "required": False},
        {"id": "hpi_detail", "label": "History of Presenting Complaints (in detail)", "type": "textarea", "required": False},

        {"id": "previous_consultation", "label": "Previous consultation", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "previous_consultation_hospital", "label": "If consulted before, hospital/clinic name", "type": "text", "required": False},

        {"id": "diabetes_mellitus", "label": "Diabetes mellitus", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "hypertension", "label": "Hypertension", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "bronchial_asthma", "label": "Bronchial asthma", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "hypothyroid", "label": "Hypothyroid", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "seizures", "label": "Seizures", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "blood_disorders", "label": "Blood disorders", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "other_medical_history", "label": "Others (medical history)", "type": "text", "required": False},

        {"id": "past_medications", "label": "Past/present medications (name, dose, frequency)", "type": "textarea", "required": False},

        {"id": "past_surgery", "label": "Any past surgical history", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "past_surgery_details", "label": "If yes, surgery name and when", "type": "text", "required": False},

        {"id": "infect_typhoid", "label": "Typhoid", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "infect_typhoid_year", "label": "If Typhoid: year", "type": "text", "required": False},
        {"id": "infect_chickenpox", "label": "Chickenpox", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "infect_chickenpox_year", "label": "If Chickenpox: year", "type": "text", "required": False},
        {"id": "infect_chikungunya", "label": "Chikungunya", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "infect_chikungunya_year", "label": "If Chikungunya: year", "type": "text", "required": False},
        {"id": "infect_malaria", "label": "Malaria", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "infect_malaria_year", "label": "If Malaria: year", "type": "text", "required": False},
        {"id": "infect_dengue", "label": "Dengue", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "infect_dengue_year", "label": "If Dengue: year", "type": "text", "required": False},
        {"id": "infect_jaundice", "label": "Jaundice", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "infect_jaundice_year", "label": "If Jaundice: year", "type": "text", "required": False},

        {"id": "supplements", "label": "Was on any multivitamins/supplements", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "supplements_details", "label": "If yes, supplement name and duration", "type": "text", "required": False},

        {"id": "allergies", "label": "Allergies", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "allergies_details", "label": "If yes, mention the drug name", "type": "text", "required": False},

        {"id": "previous_hospitalization", "label": "Previous hospitalization", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "previous_hospitalization_details", "label": "If hospitalized: for what and when", "type": "text", "required": False},

        {"id": "work_status", "label": "Work (currently employed)", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "resides_at", "label": "Resides at", "type": "text", "required": False},

        {"id": "alcohol_habits", "label": "Alcohol habits", "type": "select", "options": ["None","Occasional","Regular"], "required": False},
        {"id": "smoking_habits", "label": "Smoking habits", "type": "select", "options": ["No","Occasional","Regular"], "required": False},
        {"id": "cigarettes_per_day", "label": "If smoking: cigarettes per day", "type": "number", "required": False},
        {"id": "food_pattern", "label": "Food pattern", "type": "select", "options": ["Vegetarian","Non vegetarian","Mixed"], "required": False},
        {"id": "sleep_at", "label": "Sleep pattern (sleeps at)", "type": "time", "required": False},
        {"id": "wake_at", "label": "Sleep pattern (wakes up at)", "type": "time", "required": False},
        {"id": "physical_activity", "label": "Physical activity", "type": "select", "options": ["Sedentary","Occasional","Regularly involved"], "required": False},
        {"id": "body_weight_trend", "label": "Body weight", "type": "select", "options": ["Losing","Stable","Gaining"], "required": False},
        {"id": "stress_level", "label": "Stress level", "type": "select", "options": ["None","Mild","Moderate","High"], "required": False},
        {"id": "marital_status", "label": "Marital status", "type": "select", "options": ["Single","Married","Divorced","Widowed"], "required": False},

        {"id": "menstrual_cycle_days", "label": "Menstrual cycle (days)", "type": "number", "required": False},
        {"id": "last_menstrual_period", "label": "Last menstrual period", "type": "date", "required": False},

        {"id": "family_diabetes_mellitus", "label": "Family history: Diabetes mellitus", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "family_hypertension", "label": "Family history: Hypertension", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "family_bronchial_asthma", "label": "Family history: Bronchial asthma", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "family_hypothyroid", "label": "Family history: Hypothyroid", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "family_seizures", "label": "Family history: Seizures", "type": "select", "options": ["No","Yes"], "required": False},
        {"id": "family_others", "label": "Family history: Others", "type": "text", "required": False},
    ]
}

# Ensure fixed schema is loaded into session on first run
if ctx.get("general_schema") is None:
    ctx["general_schema"] = FIXED_GENERAL_SCHEMA

SUMMARY_PROMPT = """
You are a clinical scribe. Create a patient-friendly but clinically organized summary from the provided context.

Output format:
1) Short Narrative Paragraph (3-5 sentences) that stitches key details together for the main concern.
2) Key Points (bulleted) under these headings: Presenting Concerns; History of Present Illness; Relevant History; Medications/Allergies; Lifestyle; Red Flags/Considerations; Impression & Plan Suggestions (non-diagnostic).

Rules:
- Be concise (â‰¤ 250 words total). Use only the data provided; do not invent details.
- Include explicit negatives where available (e.g., "No drug allergies reported").
- If sections have no data, omit that bullet or write "Not specified" sparingly.
- Focus on items relevant to the presenting concern first, then supportive details.

Context (JSON):
{context_json}
"""

CHAT_ASSISTANT_SYSTEM = """
You are a clinician-assistant chatbot. Use ONLY the provided intake context.
- Do not fabricate or infer data not present in context.
- Be concise and clear. Offer guidance, not diagnosis.
- If information is missing, say so and suggest what to provide.
"""

# ---------- UI: Intake ----------
tab_intake, = st.tabs(["Intake"]) 

with tab_intake:
    # Stage switcher: details page â†’ Q&A page
    if ctx.get("ui_stage") == "details":
        st.markdown('<div class="section-title">Step 1: Basic Details</div>', unsafe_allow_html=True)

        APPT_TYPES = [
            "Dermatology","Cosmetology","Trichology (Hair)","Plastic/Cosmetic Surgery","General Medicine",
            "Endocrinology","Gynecology","ENT","Orthopedics","Other"
        ]

        def get_idx(options, value, default=0):
            try:
                return options.index(value) if value in options else default
            except Exception:
                return default

        # Entire details page inside one form so Enter submits
        with st.form("details_form"):
            appt_sel = st.selectbox("Appointment type", APPT_TYPES, index=get_idx(APPT_TYPES, ctx["appointment_type"], 2))
            col_a, col_b, col_c = st.columns(3)
            with col_a:
                nm = st.text_input("Full name", value=str(ctx["general_answers"].get("full_name","")))
            with col_b:
                try:
                    age_default = int(ctx["general_answers"].get("age", 0))
                except:
                    age_default = 0
                age_input = st.number_input("Age (years)", min_value=0, step=1, value=age_default)
            with col_c:
                gender_val = st.selectbox("Gender", ["Female","Male","Other","Prefer not to say"], index=get_idx(["Female","Male","Other","Prefer not to say"], ctx["general_answers"].get("gender","Female")))
            submitted_details = st.form_submit_button("Continue to questions â†’")

        if submitted_details:
            if nm.strip():
                ctx["general_answers"]["full_name"] = nm.strip()
            ctx["general_answers"]["age"] = int(age_input)
            ctx["general_answers"]["gender"] = gender_val
            ctx["appointment_type"] = appt_sel
            ctx["ui_stage"] = "chat"
            st.rerun()

        # Stop rendering further when on details page
        st.stop()

    # Step 2: Questions (chat-like)
    st.markdown('<div class="section-title">Step 2: Questions</div>', unsafe_allow_html=True)
    st.markdown('<div class="helper">Chat-like, one-by-one. If you don\'t want to answer, choose N/A.</div>', unsafe_allow_html=True)

    # Chat-like one-by-one flow over fixed schema
    def prepare_questions(schema: Dict[str, Any], gender_value: str, age_value: int) -> List[Dict[str, Any]]:
        result: List[Dict[str, Any]] = []
        female_only_ids = {"menstrual_cycle_days", "last_menstrual_period"}
        normalized_gender = str(gender_value).strip().lower()
        include_female_specific = normalized_gender in {"female", "other", "prefer not to say"}
        for q in safe_get_questions(schema):
            if not isinstance(q, dict):
                continue
            # Gender-based filtering: only exclude female-only questions for Male; include for Female/Other/Prefer not to say
            if (not include_female_specific) and q.get("id") in female_only_ids:
                continue
            qcopy = dict(q)
            if qcopy.get("type") == "select":
                opts = (qcopy.get("options") or [])
                if "N/A" not in opts:
                    qcopy["options"] = ["N/A"] + list(opts)
            result.append(qcopy)
        return result

    # Rebuild questions when first loading or when gender changes
    gender_value = str(ctx["general_answers"].get("gender", "")).strip()
    try:
        age_value = int(ctx["general_answers"].get("age", 0))
    except Exception:
        age_value = 0
    gender_changed = ctx["meta"].get("last_gender") != gender_value
    if ("gen_qs" not in ctx or not ctx.get("gen_qs")) or gender_changed:
        ctx["gen_qs"] = prepare_questions(ctx["general_schema"], gender_value, age_value) if ctx.get("general_schema") else []
        ctx["gen_idx"] = 0
        ctx["qa_history"] = []
        ctx["meta"]["last_gender"] = gender_value
        # Remove answers to questions no longer applicable
        female_only_ids = {"menstrual_cycle_days", "last_menstrual_period"}
        if gender_value.lower() == "male":
            for qid in female_only_ids:
                if qid in ctx["general_answers"]:
                    del ctx["general_answers"][qid]

    st.markdown('<div class="helper">Answer the current question, then click Next. Previously answered items appear below.</div>', unsafe_allow_html=True)

    i = int(ctx.get("gen_idx", 0))
    total = len(ctx.get("gen_qs", []))
    if total == 0:
        st.info("No questions are available.")
    elif i < total:
        q = ctx["gen_qs"][i]
        qid, label, qtype = q.get("id"), q.get("label"), q.get("type", "text")
        
        # Runtime conditional skip (e.g., cigarettes_per_day only if smoker)
        if qid == "cigarettes_per_day":
            smoking = str(ctx["general_answers"].get("smoking_habits", "No")).lower()
            if smoking not in ("occasional", "regular"):
                ctx["gen_idx"] = i + 1
                st.rerun()
        # Render label with compact progress: "Label (i of N)"
        st.chat_message("assistant").write(f"{label} ({i+1} of {total})")

        default_val = ctx["general_answers"].get(qid, "")
        na_key = f"na_{qid}"
        ans_key = f"ans_{qid}"

        # Entire question inside one form so Enter submits consistently
        with st.form(key=f"form_q_{qid}"):
            val: Any = None
            na_checked = False
            if qtype == "text":
                val = st.text_input("", value=str(default_val), key=ans_key)
                na_checked = st.checkbox("Mark as N/A", key=na_key)
            elif qtype == "textarea":
                val = st.text_area("", value=str(default_val), key=ans_key)
                na_checked = st.checkbox("Mark as N/A", key=na_key)
            elif qtype == "number":
                try:
                    start_val = float(default_val) if str(default_val).strip() not in ("", "N/A") else 0.0
                except Exception:
                    start_val = 0.0
                val = st.number_input("", value=start_val, key=ans_key)
                na_checked = st.checkbox("Mark as N/A", key=na_key)
            elif qtype == "select":
                options = q.get("options", []) or []
                use_options = options if options else ["N/A"]
                idx = use_options.index(default_val) if default_val in use_options else 0
                val = st.selectbox("", use_options, index=idx, key=ans_key)
            elif qtype == "date":
                val = st.date_input("", key=ans_key)
                na_checked = st.checkbox("Mark as N/A", key=na_key)
            elif qtype == "time":
                val = st.time_input("", key=ans_key)
                na_checked = st.checkbox("Mark as N/A", key=na_key)
            else:
                val = st.text_input("", value=str(default_val), key=ans_key)
                na_checked = st.checkbox("Mark as N/A", key=na_key)

            next_clicked = st.form_submit_button("Next")

        if next_clicked:
            if qtype == "select":
                answer_to_store: Any = val
            else:
                answer_to_store = "N/A" if na_checked or str(val).strip() == "" else val
            ctx["general_answers"][qid] = answer_to_store
            ctx.setdefault("qa_history", []).append({"id": qid, "label": label, "answer": answer_to_store})
            ctx["gen_idx"] = i + 1
            st.rerun()
    else:
        st.success("You\'ve answered all questions.")

    # Show prior Q/A after current
    if ctx.get("qa_history"):
        st.markdown("### Previous answers")
        for qa in ctx["qa_history"]:
            st.chat_message("assistant").write(qa.get("label", ""))
            st.chat_message("user").write(str(qa.get("answer", "")))

    st.markdown('<hr class="soft"/>', unsafe_allow_html=True)

    # (no problem-specific section)
    st.markdown('<hr class="soft"/>', unsafe_allow_html=True)

    # Step 4: Summary + transition to Chat
    st.markdown('<div class="section-title">Step 4: Generate Summary</div>', unsafe_allow_html=True)
    st.markdown('<div class="helper">Only your provided answers are used. Skipped/blank fields are excluded.</div>', unsafe_allow_html=True)

    col_s1, col_s2 = st.columns([2,1])
    with col_s1:
        if st.button("Generate patient summary"):
            payload = build_payload_for_summary(ctx)
            ctx_json = json.dumps(payload, default=str, indent=2)
            with st.spinner("Compiling summary..."):
                summary = oai_text(
                    system="You write concise, structured clinical summaries strictly from provided data.",
                    user=SUMMARY_PROMPT.format(context_json=ctx_json),
                    temperature=0.15,
                    max_tokens=700
                )
                ctx["summary"] = summary
                ctx["completed"] = True
                st.success("Summary generated below.")
    with col_s2:
        if st.button("Reset session"):
            st.session_state.pop("ctx", None)
            st.session_state.pop("sid", None)
            st.rerun()
    # Removed Chat tab navigation

    if ctx["summary"]:
        st.markdown("### Patient Summary")
        st.write(ctx["summary"])

    # Removed Chat tab
